'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _jwtDecode = require('jwt-decode');

var _jwtDecode2 = _interopRequireDefault(_jwtDecode);

var _AccountsServer = require('./AccountsServer');

var _encryption = require('./encryption');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var Accounts = void 0;

describe('Accounts', function () {
  var db = {
    findUserByUsername: function findUserByUsername() {
      return Promise.resolve();
    },
    findUserByEmail: function findUserByEmail() {
      return Promise.resolve();
    },
    createUser: function createUser() {
      return Promise.resolve();
    },
    createSession: function createSession() {
      return Promise.resolve();
    }
  };

  beforeEach(function () {
    Accounts = new _AccountsServer.AccountsServer();
    Accounts.config({}, {});
  });

  describe('hooks', function () {
    it('onLoginSuccess', _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
      var hookSpy;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              hookSpy = jest.fn(function () {
                return null;
              });

              Accounts.onLoginSuccess(hookSpy);

              Accounts.config({
                passwordAuthenticator: function passwordAuthenticator() {
                  return {};
                }
              }, {
                createSession: function createSession() {
                  return '123';
                }
              });

              _context.next = 5;
              return Accounts.loginWithPassword('username', '123456');

            case 5:
              expect(hookSpy.mock.calls.length).toBe(1);

            case 6:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, undefined);
    })));

    it('onLoginError with custom authenticator', _asyncToGenerator(regeneratorRuntime.mark(function _callee2() {
      var hookSpy;
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              hookSpy = jest.fn(function () {
                return null;
              });

              Accounts.onLoginError(hookSpy);

              Accounts.config({
                passwordAuthenticator: function passwordAuthenticator() {
                  return Promise.reject('error');
                }
              }, {
                createSession: function createSession() {
                  return '123';
                }
              });

              _context2.prev = 3;
              _context2.next = 6;
              return Accounts.loginWithPassword('username', '123456');

            case 6:
              _context2.next = 10;
              break;

            case 8:
              _context2.prev = 8;
              _context2.t0 = _context2['catch'](3);

            case 10:
              expect(hookSpy.mock.calls.length).toBe(1);

            case 11:
            case 'end':
              return _context2.stop();
          }
        }
      }, _callee2, undefined, [[3, 8]]);
    })));

    it('onLoginError with default authenticator', _asyncToGenerator(regeneratorRuntime.mark(function _callee3() {
      var hookSpy;
      return regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              hookSpy = jest.fn(function () {
                return null;
              });

              Accounts.onLoginError(hookSpy);

              Accounts.config({}, {
                findUserByUsername: function findUserByUsername() {
                  return Promise.resolve('123');
                },
                findUserByEmail: function findUserByEmail() {
                  return Promise.resolve(null);
                },
                findPasswordHash: function findPasswordHash() {
                  return Promise.resolve('hash');
                },
                verifyPassword: function verifyPassword() {
                  return Promise.resolve(false);
                }
              });

              _context3.prev = 3;
              _context3.next = 6;
              return Accounts.loginWithPassword('username', '123456');

            case 6:
              _context3.next = 10;
              break;

            case 8:
              _context3.prev = 8;
              _context3.t0 = _context3['catch'](3);

            case 10:
              expect(hookSpy.mock.calls.length).toBe(1);

            case 11:
            case 'end':
              return _context3.stop();
          }
        }
      }, _callee3, undefined, [[3, 8]]);
    })));

    it('onCreateUserSuccess', _asyncToGenerator(regeneratorRuntime.mark(function _callee4() {
      var hookSpy;
      return regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              hookSpy = jest.fn(function () {
                return null;
              });

              Accounts.onCreateUserSuccess(hookSpy);

              Accounts.config({}, _extends({}, db, {
                createUser: function createUser() {
                  return Promise.resolve('123');
                }
              }));

              _context4.next = 5;
              return Accounts.createUser({
                password: '123456',
                username: 'user1'
              });

            case 5:

              expect(hookSpy.mock.calls.length).toBe(1);

            case 6:
            case 'end':
              return _context4.stop();
          }
        }
      }, _callee4, undefined);
    })));

    it('onCreateUserError', _asyncToGenerator(regeneratorRuntime.mark(function _callee5() {
      var hookSpy;
      return regeneratorRuntime.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              hookSpy = jest.fn(function () {
                return null;
              });

              Accounts.onCreateUserError(hookSpy);

              Accounts.config({}, {
                createUser: function createUser() {
                  return Promise.reject('err');
                }
              });

              _context5.prev = 3;
              _context5.next = 6;
              return Accounts.createUser({
                password: '123456',
                username: 'user1'
              });

            case 6:
              _context5.next = 10;
              break;

            case 8:
              _context5.prev = 8;
              _context5.t0 = _context5['catch'](3);

            case 10:

              expect(hookSpy.mock.calls.length).toBe(1);

            case 11:
            case 'end':
              return _context5.stop();
          }
        }
      }, _callee5, undefined, [[3, 8]]);
    })));

    it('onLogoutSuccess', _asyncToGenerator(regeneratorRuntime.mark(function _callee6() {
      var hookSpy, invalidateSession, user, _Accounts$createToken, accessToken;

      return regeneratorRuntime.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              hookSpy = jest.fn(function () {
                return null;
              });

              Accounts.onLogoutSuccess(hookSpy);

              invalidateSession = jest.fn(function () {
                return Promise.resolve();
              });
              user = {
                userId: '123',
                username: 'username'
              };

              Accounts.config({}, {
                findSessionById: function findSessionById() {
                  return Promise.resolve({
                    sessionId: '456',
                    valid: true,
                    userId: '123'
                  });
                },
                findUserById: function findUserById() {
                  return Promise.resolve(user);
                },
                invalidateSession: invalidateSession
              });

              _Accounts$createToken = Accounts.createTokens('456'), accessToken = _Accounts$createToken.accessToken;
              _context6.next = 8;
              return Accounts.logout(accessToken);

            case 8:
              expect(hookSpy.mock.calls.length).toBe(1);

            case 9:
            case 'end':
              return _context6.stop();
          }
        }
      }, _callee6, undefined);
    })));

    it('onLogoutError', _asyncToGenerator(regeneratorRuntime.mark(function _callee7() {
      var hookSpy, _Accounts$createToken2, accessToken;

      return regeneratorRuntime.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              hookSpy = jest.fn(function () {
                return null;
              });

              Accounts.onLogoutError(hookSpy);

              Accounts.config({}, {
                findSessionById: function findSessionById() {
                  return Promise.resolve({
                    sessionId: '456',
                    valid: true,
                    userId: '123'
                  });
                },
                findUserById: function findUserById() {
                  return Promise.resolve(null);
                }
              });

              _context7.prev = 3;
              _Accounts$createToken2 = Accounts.createTokens('456'), accessToken = _Accounts$createToken2.accessToken;
              _context7.next = 7;
              return Accounts.logout(accessToken);

            case 7:
              _context7.next = 11;
              break;

            case 9:
              _context7.prev = 9;
              _context7.t0 = _context7['catch'](3);

            case 11:

              expect(hookSpy.mock.calls.length).toBe(1);

            case 12:
            case 'end':
              return _context7.stop();
          }
        }
      }, _callee7, undefined, [[3, 9]]);
    })));

    it('onResumeSessionSuccess', _asyncToGenerator(regeneratorRuntime.mark(function _callee8() {
      var hookSpy, user, _Accounts$createToken3, accessToken;

      return regeneratorRuntime.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              hookSpy = jest.fn(function () {
                return null;
              });

              Accounts.onResumeSessionSuccess(hookSpy);

              user = {
                userId: '123',
                username: 'username'
              };

              Accounts.config({ resumeSessionValidator: function resumeSessionValidator() {
                  return Promise.resolve(user);
                } }, {
                findSessionById: function findSessionById() {
                  return Promise.resolve({
                    sessionId: '456',
                    valid: true,
                    userId: '123'
                  });
                },
                findUserById: function findUserById() {
                  return Promise.resolve(user);
                }
              });

              _Accounts$createToken3 = Accounts.createTokens('456'), accessToken = _Accounts$createToken3.accessToken;
              _context8.next = 7;
              return Accounts.resumeSession(accessToken);

            case 7:

              expect(hookSpy.mock.calls.length).toBe(1);

            case 8:
            case 'end':
              return _context8.stop();
          }
        }
      }, _callee8, undefined);
    })));

    it('onResumeSessionError with invalid session', _asyncToGenerator(regeneratorRuntime.mark(function _callee9() {
      var hookSpy, user, _Accounts$createToken4, accessToken;

      return regeneratorRuntime.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              hookSpy = jest.fn(function () {
                return null;
              });

              Accounts.onResumeSessionError(hookSpy);

              user = {
                userId: '123',
                username: 'username'
              };

              Accounts.config({ resumeSessionValidator: function resumeSessionValidator() {
                  return Promise.resolve(user);
                } }, {
                findSessionById: function findSessionById() {
                  return Promise.resolve({
                    sessionId: '456',
                    valid: false,
                    userId: '123'
                  });
                },
                findUserById: function findUserById() {
                  return Promise.resolve(user);
                }
              });

              _Accounts$createToken4 = Accounts.createTokens('456'), accessToken = _Accounts$createToken4.accessToken;
              _context9.prev = 5;
              _context9.next = 8;
              return Accounts.resumeSession(accessToken);

            case 8:
              _context9.next = 12;
              break;

            case 10:
              _context9.prev = 10;
              _context9.t0 = _context9['catch'](5);

            case 12:

              expect(hookSpy.mock.calls.length).toBe(1);

            case 13:
            case 'end':
              return _context9.stop();
          }
        }
      }, _callee9, undefined, [[5, 10]]);
    })));

    it('onResumeSessionError with invalid errored session', _asyncToGenerator(regeneratorRuntime.mark(function _callee10() {
      var hookSpy, user, _Accounts$createToken5, accessToken;

      return regeneratorRuntime.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              hookSpy = jest.fn(function () {
                return null;
              });

              Accounts.onResumeSessionError(hookSpy);

              user = {
                userId: '123',
                username: 'username'
              };

              Accounts.config({ resumeSessionValidator: function resumeSessionValidator() {
                  return Promise.resolve(user);
                } }, {
                findSessionById: function findSessionById() {
                  return Promise.reject('');
                },
                findUserById: function findUserById() {
                  return Promise.resolve(user);
                }
              });

              _Accounts$createToken5 = Accounts.createTokens('456'), accessToken = _Accounts$createToken5.accessToken;
              _context10.prev = 5;
              _context10.next = 8;
              return Accounts.resumeSession(accessToken);

            case 8:
              _context10.next = 12;
              break;

            case 10:
              _context10.prev = 10;
              _context10.t0 = _context10['catch'](5);

            case 12:

              expect(hookSpy.mock.calls.length).toBe(1);

            case 13:
            case 'end':
              return _context10.stop();
          }
        }
      }, _callee10, undefined, [[5, 10]]);
    })));

    it('onRefreshTokenError', _asyncToGenerator(regeneratorRuntime.mark(function _callee11() {
      var hookSpy, _Accounts$createToken6, accessToken, refreshToken;

      return regeneratorRuntime.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              hookSpy = jest.fn(function () {
                return null;
              });

              Accounts.onRefreshTokensError(hookSpy);

              Accounts.config({}, {
                findSessionById: function findSessionById() {
                  return Promise.resolve({
                    valid: false
                  });
                }
              });
              _context11.prev = 3;
              _Accounts$createToken6 = Accounts.createTokens(), accessToken = _Accounts$createToken6.accessToken, refreshToken = _Accounts$createToken6.refreshToken;
              _context11.next = 7;
              return Accounts.refreshTokens(accessToken, refreshToken);

            case 7:
              _context11.next = 11;
              break;

            case 9:
              _context11.prev = 9;
              _context11.t0 = _context11['catch'](3);

            case 11:

              expect(hookSpy.mock.calls.length).toBe(1);

            case 12:
            case 'end':
              return _context11.stop();
          }
        }
      }, _callee11, undefined, [[3, 9]]);
    })));

    it('onRefreshTokenSuccess', _asyncToGenerator(regeneratorRuntime.mark(function _callee12() {
      var hookSpy, updateSession, user, _Accounts$createToken7, accessToken, refreshToken;

      return regeneratorRuntime.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              hookSpy = jest.fn(function () {
                return null;
              });

              Accounts.onRefreshTokensSuccess(hookSpy);

              updateSession = function updateSession() {
                return Promise.resolve();
              };

              user = {
                userId: '123',
                username: 'username'
              };

              Accounts.config({}, {
                findSessionById: function findSessionById() {
                  return Promise.resolve({
                    sessionId: '456',
                    valid: true,
                    userId: '123'
                  });
                },
                findUserById: function findUserById() {
                  return Promise.resolve(user);
                },
                updateSession: updateSession
              });
              _Accounts$createToken7 = Accounts.createTokens('456'), accessToken = _Accounts$createToken7.accessToken, refreshToken = _Accounts$createToken7.refreshToken;

              Accounts.createTokens = function () {
                return {
                  accessToken: 'newAccessToken',
                  refreshToken: 'newRefreshToken'
                };
              };

              _context12.next = 9;
              return Accounts.refreshTokens(accessToken, refreshToken, 'ip', 'user agent');

            case 9:

              expect(hookSpy.mock.calls.length).toBe(1);

            case 10:
            case 'end':
              return _context12.stop();
          }
        }
      }, _callee12, undefined);
    })));

    it('onImpersonationError', _asyncToGenerator(regeneratorRuntime.mark(function _callee13() {
      var hookSpy;
      return regeneratorRuntime.wrap(function _callee13$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              hookSpy = jest.fn(function () {
                return null;
              });

              Accounts.onImpersonationError(hookSpy);

              Accounts.config({}, db);
              _context13.prev = 3;
              _context13.next = 6;
              return Accounts.impersonate();

            case 6:
              _context13.next = 10;
              break;

            case 8:
              _context13.prev = 8;
              _context13.t0 = _context13['catch'](3);

            case 10:

              expect(hookSpy.mock.calls.length).toBe(1);

            case 11:
            case 'end':
              return _context13.stop();
          }
        }
      }, _callee13, undefined, [[3, 8]]);
    })));

    it('onImpersonationSuccess', _asyncToGenerator(regeneratorRuntime.mark(function _callee15() {
      var user, impersonatedUser, _Accounts$createToken8, accessToken, hookSpy;

      return regeneratorRuntime.wrap(function _callee15$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              user = { username: 'myUser', id: 123 };
              impersonatedUser = { username: 'impUser', id: 456 };
              _Accounts$createToken8 = Accounts.createTokens('555'), accessToken = _Accounts$createToken8.accessToken;
              hookSpy = jest.fn(function () {
                return null;
              });

              Accounts.onImpersonationSuccess(hookSpy);

              Accounts.config({
                //eslint-disable-next-line
                impersonationAuthorize: function () {
                  var _ref15 = _asyncToGenerator(regeneratorRuntime.mark(function _callee14(userObject, impersonateToUser) {
                    return regeneratorRuntime.wrap(function _callee14$(_context14) {
                      while (1) {
                        switch (_context14.prev = _context14.next) {
                          case 0:
                            return _context14.abrupt('return', userObject.id === user.id && impersonateToUser === impersonatedUser);

                          case 1:
                          case 'end':
                            return _context14.stop();
                        }
                      }
                    }, _callee14, undefined);
                  }));

                  return function impersonationAuthorize(_x, _x2) {
                    return _ref15.apply(this, arguments);
                  };
                }()
              }, {
                findUserById: function findUserById() {
                  return Promise.resolve(user);
                },
                findUserByUsername: function findUserByUsername() {
                  return Promise.resolve(impersonatedUser);
                },
                createSession: function createSession() {
                  return Promise.resolve('001');
                }
              });

              Accounts.findSessionByAccessToken = function () {
                return Promise.resolve({
                  valid: true,
                  userId: '123'
                });
              };
              Accounts.createTokens = function (sessionId, isImpersonated) {
                return { sessionId: sessionId, isImpersonated: isImpersonated };
              };

              _context15.next = 10;
              return Accounts.impersonate(accessToken, 'impUser');

            case 10:

              expect(hookSpy.mock.calls.length).toBe(1);

            case 11:
            case 'end':
              return _context15.stop();
          }
        }
      }, _callee15, undefined);
    })));
  });

  describe('config', function () {
    it('requires a db driver', function () {
      try {
        Accounts.config();
        throw new Error();
      } catch (err) {
        var message = err.message;

        expect(message).toEqual('A database driver is required');
      }
    });

    it('sets the db driver', function () {
      var testDB = {};
      Accounts.config({}, testDB);
      expect(Accounts.db).toEqual(testDB);
    });

    it('set custom password authenticator', function () {
      var testDB = {};
      Accounts.config({ passwordAuthenticator: function passwordAuthenticator() {} }, testDB);
      expect(Accounts._options.passwordAuthenticator).toBeDefined();
    });

    it('set custom userObjectSanitizer', function () {
      var testDB = {};
      var func = function func() {};
      Accounts.config({ userObjectSanitizer: func }, testDB);
      expect(Accounts._options.userObjectSanitizer).toBe(func);
    });

    it('use default password authenticator', function () {
      var testDB = {};
      Accounts.config({}, testDB);
      expect(Accounts._options.passwordAuthenticator).toBeUndefined();
    });

    it('override allowedLoginFields values', function () {
      var testDB = {};
      Accounts.config({ allowedLoginFields: ['id'] }, testDB);
      expect(Accounts._options.allowedLoginFields).toEqual(['id']);
    });

    it('default allowedLoginFields values', function () {
      var testDB = {};
      Accounts.config({}, testDB);
      expect(Accounts._options.allowedLoginFields).toEqual(['id', 'email', 'username']);
    });
  });

  describe('options', function () {
    it('should return options', function () {
      Accounts.config({ config: 'config' }, {});
      var options = Accounts.options();
      expect(options.config).toEqual('config');
    });
  });

  describe('createUser', function () {
    beforeEach(function () {
      Accounts.config({}, db);
    });
    it('requires username or an email', _asyncToGenerator(regeneratorRuntime.mark(function _callee16() {
      var message;
      return regeneratorRuntime.wrap(function _callee16$(_context16) {
        while (1) {
          switch (_context16.prev = _context16.next) {
            case 0:
              Accounts.config({}, db);
              _context16.prev = 1;
              _context16.next = 4;
              return Accounts.createUser({
                password: '123456',
                username: '',
                email: ''
              });

            case 4:
              throw new Error();

            case 7:
              _context16.prev = 7;
              _context16.t0 = _context16['catch'](1);
              message = _context16.t0.message;

              expect(message).toEqual('Username or Email is required');

            case 11:
            case 'end':
              return _context16.stop();
          }
        }
      }, _callee16, undefined, [[1, 7]]);
    })));
    it('throws error if username exists', _asyncToGenerator(regeneratorRuntime.mark(function _callee17() {
      var message;
      return regeneratorRuntime.wrap(function _callee17$(_context17) {
        while (1) {
          switch (_context17.prev = _context17.next) {
            case 0:
              Accounts.config({}, _extends({}, db, {
                findUserByUsername: function findUserByUsername() {
                  return Promise.resolve('user');
                }
              }));
              _context17.prev = 1;
              _context17.next = 4;
              return Accounts.createUser({
                password: '123456',
                username: 'user1',
                email: ''
              });

            case 4:
              throw new Error();

            case 7:
              _context17.prev = 7;
              _context17.t0 = _context17['catch'](1);
              message = _context17.t0.message;

              expect(message).toEqual('Username already exists');

            case 11:
            case 'end':
              return _context17.stop();
          }
        }
      }, _callee17, undefined, [[1, 7]]);
    })));
    it('throws error if email exists', _asyncToGenerator(regeneratorRuntime.mark(function _callee18() {
      var message;
      return regeneratorRuntime.wrap(function _callee18$(_context18) {
        while (1) {
          switch (_context18.prev = _context18.next) {
            case 0:
              Accounts.config({}, _extends({}, db, {
                findUserByEmail: function findUserByEmail() {
                  return Promise.resolve('user');
                }
              }));
              _context18.prev = 1;
              _context18.next = 4;
              return Accounts.createUser({
                password: '123456',
                username: '',
                email: 'email1@email.com'
              });

            case 4:
              throw new Error();

            case 7:
              _context18.prev = 7;
              _context18.t0 = _context18['catch'](1);
              message = _context18.t0.message;

              expect(message).toEqual('Email already exists');

            case 11:
            case 'end':
              return _context18.stop();
          }
        }
      }, _callee18, undefined, [[1, 7]]);
    })));
    it('succesfully create a user', _asyncToGenerator(regeneratorRuntime.mark(function _callee19() {
      var userId;
      return regeneratorRuntime.wrap(function _callee19$(_context19) {
        while (1) {
          switch (_context19.prev = _context19.next) {
            case 0:
              Accounts.config({}, _extends({}, db, {
                createUser: function createUser() {
                  return Promise.resolve('123');
                }
              }));
              _context19.next = 3;
              return Accounts.createUser({
                password: '123456',
                username: 'user1'
              });

            case 3:
              userId = _context19.sent;

              expect(userId).toEqual('123');

            case 5:
            case 'end':
              return _context19.stop();
          }
        }
      }, _callee19, undefined);
    })));
    it('throws error if validateNewUser does not pass', _asyncToGenerator(regeneratorRuntime.mark(function _callee20() {
      return regeneratorRuntime.wrap(function _callee20$(_context20) {
        while (1) {
          switch (_context20.prev = _context20.next) {
            case 0:
              Accounts.config({
                validateNewUser: function validateNewUser() {
                  return Promise.reject('User did not pass validation');
                }
              }, _extends({}, db, {
                createUser: function createUser() {
                  return Promise.resolve('123');
                }
              }));
              _context20.prev = 1;
              _context20.next = 4;
              return Accounts.createUser({
                password: '123456',
                username: 'user1'
              });

            case 4:
              throw Error();

            case 7:
              _context20.prev = 7;
              _context20.t0 = _context20['catch'](1);

              expect(_context20.t0).toEqual('User did not pass validation');

            case 10:
            case 'end':
              return _context20.stop();
          }
        }
      }, _callee20, undefined, [[1, 7]]);
    })));
  });

  describe('loginWithPassword - errors', function () {
    it('throws error if user is undefined', _asyncToGenerator(regeneratorRuntime.mark(function _callee21() {
      var message;
      return regeneratorRuntime.wrap(function _callee21$(_context21) {
        while (1) {
          switch (_context21.prev = _context21.next) {
            case 0:
              _context21.prev = 0;
              _context21.next = 3;
              return Accounts.loginWithPassword(null, '123456');

            case 3:
              throw new Error();

            case 6:
              _context21.prev = 6;
              _context21.t0 = _context21['catch'](0);
              message = _context21.t0.message;

              expect(message).toEqual('Unrecognized options for login request');

            case 10:
            case 'end':
              return _context21.stop();
          }
        }
      }, _callee21, undefined, [[0, 6]]);
    })));

    it('throws error if password is undefined', _asyncToGenerator(regeneratorRuntime.mark(function _callee22() {
      var message;
      return regeneratorRuntime.wrap(function _callee22$(_context22) {
        while (1) {
          switch (_context22.prev = _context22.next) {
            case 0:
              _context22.prev = 0;
              _context22.next = 3;
              return Accounts.loginWithPassword('username', null);

            case 3:
              throw new Error();

            case 6:
              _context22.prev = 6;
              _context22.t0 = _context22['catch'](0);
              message = _context22.t0.message;

              expect(message).toEqual('Unrecognized options for login request');

            case 10:
            case 'end':
              return _context22.stop();
          }
        }
      }, _callee22, undefined, [[0, 6]]);
    })));

    it('throws error if user is not a string or an object', _asyncToGenerator(regeneratorRuntime.mark(function _callee23() {
      var message;
      return regeneratorRuntime.wrap(function _callee23$(_context23) {
        while (1) {
          switch (_context23.prev = _context23.next) {
            case 0:
              _context23.prev = 0;
              _context23.next = 3;
              return Accounts.loginWithPassword(1, '123456');

            case 3:
              throw new Error();

            case 6:
              _context23.prev = 6;
              _context23.t0 = _context23['catch'](0);
              message = _context23.t0.message;

              expect(message).toEqual('Match failed');

            case 10:
            case 'end':
              return _context23.stop();
          }
        }
      }, _callee23, undefined, [[0, 6]]);
    })));

    it('throws error if password is not a string', _asyncToGenerator(regeneratorRuntime.mark(function _callee24() {
      var message;
      return regeneratorRuntime.wrap(function _callee24$(_context24) {
        while (1) {
          switch (_context24.prev = _context24.next) {
            case 0:
              _context24.prev = 0;
              _context24.next = 3;
              return Accounts.loginWithPassword('username', {});

            case 3:
              throw new Error();

            case 6:
              _context24.prev = 6;
              _context24.t0 = _context24['catch'](0);
              message = _context24.t0.message;

              expect(message).toEqual('Match failed');

            case 10:
            case 'end':
              return _context24.stop();
          }
        }
      }, _callee24, undefined, [[0, 6]]);
    })));

    it('throws error if user is not found', _asyncToGenerator(regeneratorRuntime.mark(function _callee25() {
      var message;
      return regeneratorRuntime.wrap(function _callee25$(_context25) {
        while (1) {
          switch (_context25.prev = _context25.next) {
            case 0:
              Accounts.config({}, {
                findUserByUsername: function findUserByUsername() {
                  return Promise.resolve(null);
                },
                findUserByEmail: function findUserByEmail() {
                  return Promise.resolve(null);
                }
              });
              _context25.prev = 1;
              _context25.next = 4;
              return Accounts.loginWithPassword('username', '123456');

            case 4:
              throw new Error();

            case 7:
              _context25.prev = 7;
              _context25.t0 = _context25['catch'](1);
              message = _context25.t0.message;

              expect(message).toEqual('User not found');

            case 11:
            case 'end':
              return _context25.stop();
          }
        }
      }, _callee25, undefined, [[1, 7]]);
    })));

    it('throws error if password not set', _asyncToGenerator(regeneratorRuntime.mark(function _callee26() {
      var message;
      return regeneratorRuntime.wrap(function _callee26$(_context26) {
        while (1) {
          switch (_context26.prev = _context26.next) {
            case 0:
              Accounts.config({}, {
                findUserByUsername: function findUserByUsername() {
                  return Promise.resolve('123');
                },
                findUserByEmail: function findUserByEmail() {
                  return Promise.resolve(null);
                },
                findPasswordHash: function findPasswordHash() {
                  return Promise.resolve(null);
                }
              });
              _context26.prev = 1;
              _context26.next = 4;
              return Accounts.loginWithPassword('username', '123456');

            case 4:
              throw new Error();

            case 7:
              _context26.prev = 7;
              _context26.t0 = _context26['catch'](1);
              message = _context26.t0.message;

              expect(message).toEqual('User has no password set');

            case 11:
            case 'end':
              return _context26.stop();
          }
        }
      }, _callee26, undefined, [[1, 7]]);
    })));

    it('throws error if password is incorrect', _asyncToGenerator(regeneratorRuntime.mark(function _callee27() {
      var message;
      return regeneratorRuntime.wrap(function _callee27$(_context27) {
        while (1) {
          switch (_context27.prev = _context27.next) {
            case 0:
              Accounts.config({}, {
                findUserByUsername: function findUserByUsername() {
                  return Promise.resolve('123');
                },
                findUserByEmail: function findUserByEmail() {
                  return Promise.resolve(null);
                },
                findPasswordHash: function findPasswordHash() {
                  return Promise.resolve('hash');
                },
                verifyPassword: function verifyPassword() {
                  return Promise.resolve(false);
                }
              });
              _context27.prev = 1;
              _context27.next = 4;
              return Accounts.loginWithPassword('username', '123456');

            case 4:
              throw new Error();

            case 7:
              _context27.prev = 7;
              _context27.t0 = _context27['catch'](1);
              message = _context27.t0.message;

              expect(message).toEqual('Incorrect password');

            case 11:
            case 'end':
              return _context27.stop();
          }
        }
      }, _callee27, undefined, [[1, 7]]);
    })));

    it('should use custom password authenticator when specified', _asyncToGenerator(regeneratorRuntime.mark(function _callee28() {
      var user, authenticator, result;
      return regeneratorRuntime.wrap(function _callee28$(_context28) {
        while (1) {
          switch (_context28.prev = _context28.next) {
            case 0:
              user = {
                id: '123',
                username: 'username',
                email: 'email@email.com',
                profile: {
                  bio: 'bio'
                }
              };
              authenticator = jest.fn(function () {
                return Promise.resolve(user);
              });


              Accounts.config({ passwordAuthenticator: authenticator }, db);

              _context28.next = 5;
              return Accounts.loginWithPassword('username', '123456');

            case 5:
              result = _context28.sent;


              expect(result).toBeDefined();
              expect(authenticator.mock.calls.length).toEqual(1);

            case 8:
            case 'end':
              return _context28.stop();
          }
        }
      }, _callee28, undefined);
    })));

    it('return user with custom validation method', _asyncToGenerator(regeneratorRuntime.mark(function _callee29() {
      var resumeSessionValidator, user, _Accounts$createToken9, accessToken;

      return regeneratorRuntime.wrap(function _callee29$(_context29) {
        while (1) {
          switch (_context29.prev = _context29.next) {
            case 0:
              resumeSessionValidator = jest.fn(function () {
                return Promise.resolve({});
              });
              user = {
                userId: '123',
                username: 'username'
              };

              Accounts.config({ resumeSessionValidator: resumeSessionValidator }, {
                findSessionById: function findSessionById() {
                  return Promise.resolve({
                    sessionId: '456',
                    valid: true,
                    userId: '123'
                  });
                },
                findUserById: function findUserById() {
                  return Promise.resolve(user);
                }
              });

              _Accounts$createToken9 = Accounts.createTokens('456'), accessToken = _Accounts$createToken9.accessToken;
              _context29.next = 6;
              return Accounts.resumeSession(accessToken);

            case 6:

              expect(resumeSessionValidator.mock.calls.length).toBe(1);

            case 7:
            case 'end':
              return _context29.stop();
          }
        }
      }, _callee29, undefined);
    })));

    it('throw when custom validation method rejects', _asyncToGenerator(regeneratorRuntime.mark(function _callee30() {
      var resumeSessionValidator, user, _Accounts$createToken10, accessToken;

      return regeneratorRuntime.wrap(function _callee30$(_context30) {
        while (1) {
          switch (_context30.prev = _context30.next) {
            case 0:
              resumeSessionValidator = jest.fn(function () {
                return Promise.reject('Custom session error');
              });
              user = {
                userId: '123',
                username: 'username'
              };

              Accounts.config({ resumeSessionValidator: resumeSessionValidator }, {
                findSessionById: function findSessionById() {
                  return Promise.resolve({
                    sessionId: '456',
                    valid: true,
                    userId: '123'
                  });
                },
                findUserById: function findUserById() {
                  return Promise.resolve(user);
                }
              });

              _Accounts$createToken10 = Accounts.createTokens('456'), accessToken = _Accounts$createToken10.accessToken;
              _context30.prev = 4;
              _context30.next = 7;
              return Accounts.resumeSession(accessToken);

            case 7:
              throw new Error();

            case 10:
              _context30.prev = 10;
              _context30.t0 = _context30['catch'](4);

              expect(resumeSessionValidator.mock.calls.length).toBe(1);
              expect(_context30.t0.message).toEqual('Custom session error');

            case 14:
            case 'end':
              return _context30.stop();
          }
        }
      }, _callee30, undefined, [[4, 10]]);
    })));
  });

  describe('loginWithUser', function () {
    it('login using id', _asyncToGenerator(regeneratorRuntime.mark(function _callee31() {
      var hash, user, findUserById, res, _res$tokens, accessToken, refreshToken, decodedAccessToken;

      return regeneratorRuntime.wrap(function _callee31$(_context31) {
        while (1) {
          switch (_context31.prev = _context31.next) {
            case 0:
              hash = (0, _encryption.bcryptPassword)('1234567');
              user = {
                id: '123',
                username: 'username',
                email: 'email@email.com',
                profile: {
                  bio: 'bio'
                }
              };
              findUserById = jest.fn(function () {
                return Promise.resolve(user);
              });

              Accounts.config({}, {
                findUserById: findUserById,
                findPasswordHash: function findPasswordHash() {
                  return Promise.resolve(hash);
                },
                createSession: function createSession() {
                  return Promise.resolve('sessionId');
                }
              });
              _context31.next = 6;
              return Accounts.loginWithPassword({ id: '123' }, '1234567');

            case 6:
              res = _context31.sent;

              expect(findUserById.mock.calls[0][0]).toEqual('123');
              expect(res.user).toEqual(user);
              _res$tokens = res.tokens, accessToken = _res$tokens.accessToken, refreshToken = _res$tokens.refreshToken;
              decodedAccessToken = (0, _jwtDecode2.default)(accessToken);

              expect(decodedAccessToken.data.sessionId).toEqual('sessionId');
              expect(accessToken).toBeTruthy();
              expect(refreshToken).toBeTruthy();

            case 14:
            case 'end':
              return _context31.stop();
          }
        }
      }, _callee31, undefined);
    })));

    it('try to login using id and password when id login is not allowed', _asyncToGenerator(regeneratorRuntime.mark(function _callee32() {
      var hash, user, findUserById;
      return regeneratorRuntime.wrap(function _callee32$(_context32) {
        while (1) {
          switch (_context32.prev = _context32.next) {
            case 0:
              hash = (0, _encryption.bcryptPassword)('1234567');
              user = {
                id: '123',
                username: 'username',
                email: 'email@email.com',
                profile: {
                  bio: 'bio'
                }
              };
              findUserById = jest.fn(function () {
                return Promise.resolve(user);
              });

              Accounts.config({
                allowedLoginFields: ['email']
              }, {
                findUserById: findUserById,
                findPasswordHash: function findPasswordHash() {
                  return Promise.resolve(hash);
                },
                createSession: function createSession() {
                  return Promise.resolve('sessionId');
                }
              });

              _context32.prev = 4;
              _context32.next = 7;
              return Accounts.loginWithPassword({ id: '123' }, '1234567');

            case 7:
              throw new Error();

            case 10:
              _context32.prev = 10;
              _context32.t0 = _context32['catch'](4);

              expect(_context32.t0.message).toEqual('Login with id is not allowed!');

            case 13:
            case 'end':
              return _context32.stop();
          }
        }
      }, _callee32, undefined, [[4, 10]]);
    })));

    it('try to login using id and password when id login only is allowed ', _asyncToGenerator(regeneratorRuntime.mark(function _callee33() {
      var hash, user, findUserById, res;
      return regeneratorRuntime.wrap(function _callee33$(_context33) {
        while (1) {
          switch (_context33.prev = _context33.next) {
            case 0:
              hash = (0, _encryption.bcryptPassword)('1234567');
              user = {
                id: '123',
                username: 'username',
                email: 'email@email.com',
                profile: {
                  bio: 'bio'
                }
              };
              findUserById = jest.fn(function () {
                return Promise.resolve(user);
              });

              Accounts.config({
                allowedLoginFields: ['id']
              }, {
                findUserById: findUserById,
                findPasswordHash: function findPasswordHash() {
                  return Promise.resolve(hash);
                },
                createSession: function createSession() {
                  return Promise.resolve('sessionId');
                }
              });

              _context33.next = 6;
              return Accounts.loginWithPassword({ id: '123' }, '1234567');

            case 6:
              res = _context33.sent;

              expect(res).toBeDefined();

            case 8:
            case 'end':
              return _context33.stop();
          }
        }
      }, _callee33, undefined);
    })));

    it('supports hashed password from the client', _asyncToGenerator(regeneratorRuntime.mark(function _callee34() {
      var hash, user, findUserById, res, _res$tokens2, accessToken, refreshToken, decodedAccessToken;

      return regeneratorRuntime.wrap(function _callee34$(_context34) {
        while (1) {
          switch (_context34.prev = _context34.next) {
            case 0:
              hash = (0, _encryption.bcryptPassword)((0, _encryption.hashPassword)('1234567', 'sha256'));
              user = {
                id: '123',
                username: 'username',
                email: 'email@email.com',
                profile: {
                  bio: 'bio'
                }
              };
              findUserById = jest.fn(function () {
                return Promise.resolve(user);
              });

              Accounts.config({
                passwordHashAlgorithm: 'sha256'
              }, {
                findUserById: findUserById,
                findPasswordHash: function findPasswordHash() {
                  return Promise.resolve(hash);
                },
                createSession: function createSession() {
                  return Promise.resolve('sessionId');
                }
              });

              _context34.next = 6;
              return Accounts.loginWithPassword({ id: '123' }, '1234567');

            case 6:
              res = _context34.sent;

              expect(findUserById.mock.calls[0][0]).toEqual('123');
              expect(res.user).toEqual(user);

              _res$tokens2 = res.tokens, accessToken = _res$tokens2.accessToken, refreshToken = _res$tokens2.refreshToken;
              decodedAccessToken = (0, _jwtDecode2.default)(accessToken);

              expect(decodedAccessToken.data.sessionId).toEqual('sessionId');
              expect(accessToken).toBeTruthy();
              expect(refreshToken).toBeTruthy();

            case 14:
            case 'end':
              return _context34.stop();
          }
        }
      }, _callee34, undefined);
    })));
  });

  describe('refreshTokens', function () {
    it('updates session and returns new tokens and user', _asyncToGenerator(regeneratorRuntime.mark(function _callee35() {
      var updateSession, user, _Accounts$createToken11, accessToken, refreshToken, res;

      return regeneratorRuntime.wrap(function _callee35$(_context35) {
        while (1) {
          switch (_context35.prev = _context35.next) {
            case 0:
              updateSession = jest.fn(function () {
                return Promise.resolve();
              });
              user = {
                userId: '123',
                username: 'username'
              };

              Accounts.config({}, {
                findSessionById: function findSessionById() {
                  return Promise.resolve({
                    sessionId: '456',
                    valid: true,
                    userId: '123'
                  });
                },
                findUserById: function findUserById() {
                  return Promise.resolve(user);
                },
                updateSession: updateSession
              });
              _Accounts$createToken11 = Accounts.createTokens('456'), accessToken = _Accounts$createToken11.accessToken, refreshToken = _Accounts$createToken11.refreshToken;

              Accounts.createTokens = function () {
                return {
                  accessToken: 'newAccessToken',
                  refreshToken: 'newRefreshToken'
                };
              };
              _context35.next = 7;
              return Accounts.refreshTokens(accessToken, refreshToken, 'ip', 'user agent');

            case 7:
              res = _context35.sent;

              expect(updateSession.mock.calls[0]).toEqual(['456', 'ip', 'user agent']);
              expect(res.user).toEqual({
                userId: '123',
                username: 'username'
              });

            case 10:
            case 'end':
              return _context35.stop();
          }
        }
      }, _callee35, undefined);
    })));

    it('requires access and refresh tokens', _asyncToGenerator(regeneratorRuntime.mark(function _callee36() {
      return regeneratorRuntime.wrap(function _callee36$(_context36) {
        while (1) {
          switch (_context36.prev = _context36.next) {
            case 0:
              Accounts.config({}, {});
              _context36.prev = 1;
              _context36.next = 4;
              return Accounts.refreshTokens();

            case 4:
              throw new Error();

            case 7:
              _context36.prev = 7;
              _context36.t0 = _context36['catch'](1);

              expect(_context36.t0.message).toEqual('An accessToken and refreshToken are required');

            case 10:
            case 'end':
              return _context36.stop();
          }
        }
      }, _callee36, undefined, [[1, 7]]);
    })));
    it('throws error if tokens are not valid', _asyncToGenerator(regeneratorRuntime.mark(function _callee37() {
      return regeneratorRuntime.wrap(function _callee37$(_context37) {
        while (1) {
          switch (_context37.prev = _context37.next) {
            case 0:
              Accounts.config({}, {});
              _context37.prev = 1;
              _context37.next = 4;
              return Accounts.refreshTokens('bad access token', 'bad refresh token');

            case 4:
              throw new Error();

            case 7:
              _context37.prev = 7;
              _context37.t0 = _context37['catch'](1);

              expect(_context37.t0.message).toEqual('Tokens are not valid');

            case 10:
            case 'end':
              return _context37.stop();
          }
        }
      }, _callee37, undefined, [[1, 7]]);
    })));
    it('throws error if session not found', _asyncToGenerator(regeneratorRuntime.mark(function _callee38() {
      var _Accounts$createToken12, accessToken, refreshToken;

      return regeneratorRuntime.wrap(function _callee38$(_context38) {
        while (1) {
          switch (_context38.prev = _context38.next) {
            case 0:
              Accounts.config({}, {
                findSessionById: function findSessionById() {
                  return Promise.resolve(null);
                }
              });
              _context38.prev = 1;
              _Accounts$createToken12 = Accounts.createTokens(), accessToken = _Accounts$createToken12.accessToken, refreshToken = _Accounts$createToken12.refreshToken;
              _context38.next = 5;
              return Accounts.refreshTokens(accessToken, refreshToken);

            case 5:
              throw new Error();

            case 8:
              _context38.prev = 8;
              _context38.t0 = _context38['catch'](1);

              expect(_context38.t0.message).toEqual('Session not found');

            case 11:
            case 'end':
              return _context38.stop();
          }
        }
      }, _callee38, undefined, [[1, 8]]);
    })));
    it('throws error if session not valid', _asyncToGenerator(regeneratorRuntime.mark(function _callee39() {
      var _Accounts$createToken13, accessToken, refreshToken;

      return regeneratorRuntime.wrap(function _callee39$(_context39) {
        while (1) {
          switch (_context39.prev = _context39.next) {
            case 0:
              Accounts.config({}, {
                findSessionById: function findSessionById() {
                  return Promise.resolve({
                    valid: false
                  });
                }
              });
              _context39.prev = 1;
              _Accounts$createToken13 = Accounts.createTokens(), accessToken = _Accounts$createToken13.accessToken, refreshToken = _Accounts$createToken13.refreshToken;
              _context39.next = 5;
              return Accounts.refreshTokens(accessToken, refreshToken);

            case 5:
              throw new Error();

            case 8:
              _context39.prev = 8;
              _context39.t0 = _context39['catch'](1);

              expect(_context39.t0.message).toEqual('Session is no longer valid');

            case 11:
            case 'end':
              return _context39.stop();
          }
        }
      }, _callee39, undefined, [[1, 8]]);
    })));
  });

  describe('logout', function () {
    it('throws error if user is not found', _asyncToGenerator(regeneratorRuntime.mark(function _callee40() {
      var _Accounts$createToken14, accessToken, message;

      return regeneratorRuntime.wrap(function _callee40$(_context40) {
        while (1) {
          switch (_context40.prev = _context40.next) {
            case 0:
              Accounts.config({}, {
                findSessionById: function findSessionById() {
                  return Promise.resolve({
                    sessionId: '456',
                    valid: true,
                    userId: '123'
                  });
                },
                findUserById: function findUserById() {
                  return Promise.resolve(null);
                }
              });
              _context40.prev = 1;
              _Accounts$createToken14 = Accounts.createTokens('456'), accessToken = _Accounts$createToken14.accessToken;
              _context40.next = 5;
              return Accounts.logout(accessToken);

            case 5:
              throw new Error();

            case 8:
              _context40.prev = 8;
              _context40.t0 = _context40['catch'](1);
              message = _context40.t0.message;

              expect(message).toEqual('User not found');

            case 12:
            case 'end':
              return _context40.stop();
          }
        }
      }, _callee40, undefined, [[1, 8]]);
    })));

    it('invalidates session', _asyncToGenerator(regeneratorRuntime.mark(function _callee41() {
      var invalidateSession, user, _Accounts$createToken15, accessToken;

      return regeneratorRuntime.wrap(function _callee41$(_context41) {
        while (1) {
          switch (_context41.prev = _context41.next) {
            case 0:
              invalidateSession = jest.fn(function () {
                return Promise.resolve();
              });
              user = {
                userId: '123',
                username: 'username'
              };

              Accounts.config({}, {
                findSessionById: function findSessionById() {
                  return Promise.resolve({
                    sessionId: '456',
                    valid: true,
                    userId: '123'
                  });
                },
                findUserById: function findUserById() {
                  return Promise.resolve(user);
                },
                invalidateSession: invalidateSession
              });
              _Accounts$createToken15 = Accounts.createTokens('456'), accessToken = _Accounts$createToken15.accessToken;
              _context41.next = 6;
              return Accounts.logout(accessToken);

            case 6:
              expect(invalidateSession.mock.calls[0]).toEqual(['456']);

            case 7:
            case 'end':
              return _context41.stop();
          }
        }
      }, _callee41, undefined);
    })));
  });

  describe('findSessionByAccessToken', function () {
    it('requires access token', _asyncToGenerator(regeneratorRuntime.mark(function _callee42() {
      return regeneratorRuntime.wrap(function _callee42$(_context42) {
        while (1) {
          switch (_context42.prev = _context42.next) {
            case 0:
              Accounts.config({}, {});
              _context42.prev = 1;
              _context42.next = 4;
              return Accounts.logout();

            case 4:
              throw new Error();

            case 7:
              _context42.prev = 7;
              _context42.t0 = _context42['catch'](1);

              expect(_context42.t0.message).toEqual('An accessToken is required');

            case 10:
            case 'end':
              return _context42.stop();
          }
        }
      }, _callee42, undefined, [[1, 7]]);
    })));
    it('throws error if tokens are not valid', _asyncToGenerator(regeneratorRuntime.mark(function _callee43() {
      return regeneratorRuntime.wrap(function _callee43$(_context43) {
        while (1) {
          switch (_context43.prev = _context43.next) {
            case 0:
              Accounts.config({}, {});
              _context43.prev = 1;
              _context43.next = 4;
              return Accounts.logout('bad access token');

            case 4:
              throw new Error();

            case 7:
              _context43.prev = 7;
              _context43.t0 = _context43['catch'](1);

              expect(_context43.t0.message).toEqual('Tokens are not valid');

            case 10:
            case 'end':
              return _context43.stop();
          }
        }
      }, _callee43, undefined, [[1, 7]]);
    })));
    it('throws error if session not found', _asyncToGenerator(regeneratorRuntime.mark(function _callee44() {
      var _Accounts$createToken16, accessToken;

      return regeneratorRuntime.wrap(function _callee44$(_context44) {
        while (1) {
          switch (_context44.prev = _context44.next) {
            case 0:
              Accounts.config({}, {
                findSessionById: function findSessionById() {
                  return Promise.resolve(null);
                }
              });
              _context44.prev = 1;
              _Accounts$createToken16 = Accounts.createTokens(), accessToken = _Accounts$createToken16.accessToken;
              _context44.next = 5;
              return Accounts.logout(accessToken);

            case 5:
              throw new Error();

            case 8:
              _context44.prev = 8;
              _context44.t0 = _context44['catch'](1);

              expect(_context44.t0.message).toEqual('Session not found');

            case 11:
            case 'end':
              return _context44.stop();
          }
        }
      }, _callee44, undefined, [[1, 8]]);
    })));
    it('throws error if session not valid', _asyncToGenerator(regeneratorRuntime.mark(function _callee45() {
      var _Accounts$createToken17, accessToken;

      return regeneratorRuntime.wrap(function _callee45$(_context45) {
        while (1) {
          switch (_context45.prev = _context45.next) {
            case 0:
              Accounts.config({}, {
                findSessionById: function findSessionById() {
                  return Promise.resolve({
                    valid: false
                  });
                }
              });
              _context45.prev = 1;
              _Accounts$createToken17 = Accounts.createTokens(), accessToken = _Accounts$createToken17.accessToken;
              _context45.next = 5;
              return Accounts.logout(accessToken);

            case 5:
              throw new Error();

            case 8:
              _context45.prev = 8;
              _context45.t0 = _context45['catch'](1);

              expect(_context45.t0.message).toEqual('Session is no longer valid');

            case 11:
            case 'end':
              return _context45.stop();
          }
        }
      }, _callee45, undefined, [[1, 8]]);
    })));
  });

  describe('findUserByEmail', function () {
    it('call this.db.findUserByEmail', _asyncToGenerator(regeneratorRuntime.mark(function _callee46() {
      var findUserByEmail, user;
      return regeneratorRuntime.wrap(function _callee46$(_context46) {
        while (1) {
          switch (_context46.prev = _context46.next) {
            case 0:
              findUserByEmail = jest.fn(function () {
                return Promise.resolve('user');
              });

              Accounts.config({}, { findUserByEmail: findUserByEmail });
              _context46.next = 4;
              return Accounts.findUserByEmail('email');

            case 4:
              user = _context46.sent;

              expect(findUserByEmail.mock.calls[0]).toEqual(['email']);
              expect(user).toEqual('user');

            case 7:
            case 'end':
              return _context46.stop();
          }
        }
      }, _callee46, undefined);
    })));
  });

  describe('findUserByUsername', function () {
    it('call this.db.findUserByUsername', _asyncToGenerator(regeneratorRuntime.mark(function _callee47() {
      var findUserByUsername, user;
      return regeneratorRuntime.wrap(function _callee47$(_context47) {
        while (1) {
          switch (_context47.prev = _context47.next) {
            case 0:
              findUserByUsername = jest.fn(function () {
                return Promise.resolve('user');
              });

              Accounts.config({}, { findUserByUsername: findUserByUsername });
              _context47.next = 4;
              return Accounts.findUserByUsername('username');

            case 4:
              user = _context47.sent;

              expect(findUserByUsername.mock.calls[0]).toEqual(['username']);
              expect(user).toEqual('user');

            case 7:
            case 'end':
              return _context47.stop();
          }
        }
      }, _callee47, undefined);
    })));
  });

  describe('findUserById', function () {
    it('call this.db.findUserById', _asyncToGenerator(regeneratorRuntime.mark(function _callee48() {
      var findUserById, user;
      return regeneratorRuntime.wrap(function _callee48$(_context48) {
        while (1) {
          switch (_context48.prev = _context48.next) {
            case 0:
              findUserById = jest.fn(function () {
                return Promise.resolve('user');
              });

              Accounts.config({}, { findUserById: findUserById });
              _context48.next = 4;
              return Accounts.findUserById('id');

            case 4:
              user = _context48.sent;

              expect(findUserById.mock.calls[0]).toEqual(['id']);
              expect(user).toEqual('user');

            case 7:
            case 'end':
              return _context48.stop();
          }
        }
      }, _callee48, undefined);
    })));
  });

  describe('addEmail', function () {
    it('call this.db.addEmail', _asyncToGenerator(regeneratorRuntime.mark(function _callee49() {
      var addEmail;
      return regeneratorRuntime.wrap(function _callee49$(_context49) {
        while (1) {
          switch (_context49.prev = _context49.next) {
            case 0:
              addEmail = jest.fn(function () {
                return Promise.resolve();
              });

              Accounts.config({}, { addEmail: addEmail });
              _context49.next = 4;
              return Accounts.addEmail('id', 'email', true);

            case 4:
              expect(addEmail.mock.calls[0]).toEqual(['id', 'email', true]);

            case 5:
            case 'end':
              return _context49.stop();
          }
        }
      }, _callee49, undefined);
    })));
  });

  describe('removeEmail', function () {
    it('call this.db.removeEmail', _asyncToGenerator(regeneratorRuntime.mark(function _callee50() {
      var removeEmail;
      return regeneratorRuntime.wrap(function _callee50$(_context50) {
        while (1) {
          switch (_context50.prev = _context50.next) {
            case 0:
              removeEmail = jest.fn(function () {
                return Promise.resolve();
              });

              Accounts.config({}, { removeEmail: removeEmail });
              _context50.next = 4;
              return Accounts.removeEmail('id', 'email');

            case 4:
              expect(removeEmail.mock.calls[0]).toEqual(['id', 'email']);

            case 5:
            case 'end':
              return _context50.stop();
          }
        }
      }, _callee50, undefined);
    })));
  });

  describe('resumeSession', function () {
    it('throws error if user is not found', _asyncToGenerator(regeneratorRuntime.mark(function _callee51() {
      var _Accounts$createToken18, accessToken, message;

      return regeneratorRuntime.wrap(function _callee51$(_context51) {
        while (1) {
          switch (_context51.prev = _context51.next) {
            case 0:
              Accounts.config({}, {
                findSessionById: function findSessionById() {
                  return Promise.resolve({
                    sessionId: '456',
                    valid: true,
                    userId: '123'
                  });
                },
                findUserById: function findUserById() {
                  return Promise.resolve(null);
                }
              });
              _context51.prev = 1;
              _Accounts$createToken18 = Accounts.createTokens('456'), accessToken = _Accounts$createToken18.accessToken;
              _context51.next = 5;
              return Accounts.resumeSession(accessToken);

            case 5:
              throw new Error();

            case 8:
              _context51.prev = 8;
              _context51.t0 = _context51['catch'](1);
              message = _context51.t0.message;

              expect(message).toEqual('User not found');

            case 12:
            case 'end':
              return _context51.stop();
          }
        }
      }, _callee51, undefined, [[1, 8]]);
    })));

    it('return false if session is not valid', _asyncToGenerator(regeneratorRuntime.mark(function _callee52() {
      var user, _Accounts$createToken19, accessToken, ret;

      return regeneratorRuntime.wrap(function _callee52$(_context52) {
        while (1) {
          switch (_context52.prev = _context52.next) {
            case 0:
              user = {
                userId: '123',
                username: 'username'
              };

              Accounts.config({}, {
                findSessionById: function findSessionById() {
                  return Promise.resolve({
                    sessionId: '456',
                    valid: false,
                    userId: '123'
                  });
                },
                findUserById: function findUserById() {
                  return Promise.resolve(user);
                }
              });
              _Accounts$createToken19 = Accounts.createTokens('456'), accessToken = _Accounts$createToken19.accessToken;
              _context52.next = 5;
              return Accounts.resumeSession(accessToken);

            case 5:
              ret = _context52.sent;

              expect(ret).not.toBeTruthy();

            case 7:
            case 'end':
              return _context52.stop();
          }
        }
      }, _callee52, undefined);
    })));

    it('return user', _asyncToGenerator(regeneratorRuntime.mark(function _callee53() {
      var user, _Accounts$createToken20, accessToken, foundUser;

      return regeneratorRuntime.wrap(function _callee53$(_context53) {
        while (1) {
          switch (_context53.prev = _context53.next) {
            case 0:
              user = {
                userId: '123',
                username: 'username'
              };

              Accounts.config({}, {
                findSessionById: function findSessionById() {
                  return Promise.resolve({
                    sessionId: '456',
                    valid: true,
                    userId: '123'
                  });
                },
                findUserById: function findUserById() {
                  return Promise.resolve(user);
                }
              });
              _Accounts$createToken20 = Accounts.createTokens('456'), accessToken = _Accounts$createToken20.accessToken;
              _context53.next = 5;
              return Accounts.resumeSession(accessToken);

            case 5:
              foundUser = _context53.sent;

              expect(foundUser).toEqual(user);

            case 7:
            case 'end':
              return _context53.stop();
          }
        }
      }, _callee53, undefined);
    })));
  });

  describe('setProfile', function () {
    it('throws error if user is not found', _asyncToGenerator(regeneratorRuntime.mark(function _callee54() {
      var message;
      return regeneratorRuntime.wrap(function _callee54$(_context54) {
        while (1) {
          switch (_context54.prev = _context54.next) {
            case 0:
              Accounts.config({}, {
                findUserById: function findUserById() {
                  return Promise.resolve(null);
                }
              });
              _context54.prev = 1;
              _context54.next = 4;
              return Accounts.setProfile();

            case 4:
              throw new Error();

            case 7:
              _context54.prev = 7;
              _context54.t0 = _context54['catch'](1);
              message = _context54.t0.message;

              expect(message).toEqual('User not found');

            case 11:
            case 'end':
              return _context54.stop();
          }
        }
      }, _callee54, undefined, [[1, 7]]);
    })));

    it('calls set profile on db interface', _asyncToGenerator(regeneratorRuntime.mark(function _callee55() {
      var user, profile, setProfile;
      return regeneratorRuntime.wrap(function _callee55$(_context55) {
        while (1) {
          switch (_context55.prev = _context55.next) {
            case 0:
              user = {
                userId: '123',
                username: 'username'
              };
              profile = {
                bio: 'bio'
              };
              setProfile = jest.fn();

              Accounts.config({}, {
                findUserById: function findUserById() {
                  return Promise.resolve(user);
                },
                setProfile: setProfile
              });
              _context55.next = 6;
              return Accounts.setProfile('123', profile);

            case 6:
              expect(setProfile.mock.calls.length).toEqual(1);
              expect(setProfile.mock.calls[0][0]).toEqual('123');
              expect(setProfile.mock.calls[0][1]).toEqual(profile);

            case 9:
            case 'end':
              return _context55.stop();
          }
        }
      }, _callee55, undefined);
    })));

    it('merges profile and calls set profile on db interface', _asyncToGenerator(regeneratorRuntime.mark(function _callee56() {
      var user, profile, mergedProfile, setProfile, res;
      return regeneratorRuntime.wrap(function _callee56$(_context56) {
        while (1) {
          switch (_context56.prev = _context56.next) {
            case 0:
              user = {
                userId: '123',
                username: 'username',
                profile: {
                  title: 'title'
                }
              };
              profile = {
                bio: 'bio'
              };
              mergedProfile = {
                title: 'title',
                bio: 'bio'
              };
              setProfile = jest.fn(function () {
                return mergedProfile;
              });

              Accounts.config({}, {
                findUserById: function findUserById() {
                  return Promise.resolve(user);
                },
                setProfile: setProfile
              });
              _context56.next = 7;
              return Accounts.updateProfile('123', profile);

            case 7:
              res = _context56.sent;

              expect(setProfile.mock.calls.length).toEqual(1);
              expect(setProfile.mock.calls[0][0]).toEqual('123');
              expect(setProfile.mock.calls[0][1]).toEqual(mergedProfile);
              expect(res).toEqual(mergedProfile);

            case 12:
            case 'end':
              return _context56.stop();
          }
        }
      }, _callee56, undefined);
    })));
  });

  describe('sendVerificationEmail', function () {
    it('throws error if user is not found', _asyncToGenerator(regeneratorRuntime.mark(function _callee57() {
      return regeneratorRuntime.wrap(function _callee57$(_context57) {
        while (1) {
          switch (_context57.prev = _context57.next) {
            case 0:
              Accounts.config({}, {
                findUserByEmail: function findUserByEmail() {
                  return Promise.resolve(null);
                }
              });
              _context57.prev = 1;
              _context57.next = 4;
              return Accounts.sendVerificationEmail();

            case 4:
              throw new Error();

            case 7:
              _context57.prev = 7;
              _context57.t0 = _context57['catch'](1);

              expect(_context57.t0.message).toEqual('User not found');

            case 10:
            case 'end':
              return _context57.stop();
          }
        }
      }, _callee57, undefined, [[1, 7]]);
    })));

    it('throws when bad email address passed', _asyncToGenerator(regeneratorRuntime.mark(function _callee58() {
      var user;
      return regeneratorRuntime.wrap(function _callee58$(_context58) {
        while (1) {
          switch (_context58.prev = _context58.next) {
            case 0:
              user = {
                emails: [{ address: 'email' }]
              };

              Accounts.config({}, {
                findUserByEmail: function findUserByEmail() {
                  return Promise.resolve(user);
                }
              });
              _context58.prev = 2;
              _context58.next = 5;
              return Accounts.sendVerificationEmail('toto');

            case 5:
              throw new Error();

            case 8:
              _context58.prev = 8;
              _context58.t0 = _context58['catch'](2);

              expect(_context58.t0.message).toEqual('No such email address for user');

            case 11:
            case 'end':
              return _context58.stop();
          }
        }
      }, _callee58, undefined, [[2, 8]]);
    })));

    it('should send to first unverified email', _asyncToGenerator(regeneratorRuntime.mark(function _callee59() {
      var user;
      return regeneratorRuntime.wrap(function _callee59$(_context59) {
        while (1) {
          switch (_context59.prev = _context59.next) {
            case 0:
              user = {
                emails: [{ address: 'email' }]
              };

              Accounts.config({}, {
                findUserByEmail: function findUserByEmail() {
                  return Promise.resolve(user);
                },
                addEmailVerificationToken: function addEmailVerificationToken() {
                  return Promise.resolve('token');
                }
              });
              Accounts.email = { sendMail: jest.fn() };
              _context59.next = 5;
              return Accounts.sendVerificationEmail('email');

            case 5:
              expect(Accounts.email.sendMail.mock.calls.length).toEqual(1);
              expect(Accounts.email.sendMail.mock.calls[0][0].from).toBeTruthy();
              expect(Accounts.email.sendMail.mock.calls[0][0].to).toEqual('email');
              expect(Accounts.email.sendMail.mock.calls[0][0].subject).toBeTruthy();
              expect(Accounts.email.sendMail.mock.calls[0][0].text).toBeTruthy();

            case 10:
            case 'end':
              return _context59.stop();
          }
        }
      }, _callee59, undefined);
    })));

    it('should send email', _asyncToGenerator(regeneratorRuntime.mark(function _callee60() {
      var user;
      return regeneratorRuntime.wrap(function _callee60$(_context60) {
        while (1) {
          switch (_context60.prev = _context60.next) {
            case 0:
              user = {
                emails: [{ address: 'email' }]
              };

              Accounts.config({}, {
                findUserByEmail: function findUserByEmail() {
                  return Promise.resolve(user);
                },
                addEmailVerificationToken: function addEmailVerificationToken() {
                  return Promise.resolve('token');
                }
              });
              Accounts.email = { sendMail: jest.fn() };
              _context60.next = 5;
              return Accounts.sendVerificationEmail('email');

            case 5:
              expect(Accounts.email.sendMail.mock.calls.length).toEqual(1);
              expect(Accounts.email.sendMail.mock.calls[0][0].from).toBeTruthy();
              expect(Accounts.email.sendMail.mock.calls[0][0].to).toEqual('email');
              expect(Accounts.email.sendMail.mock.calls[0][0].subject).toBeTruthy();
              expect(Accounts.email.sendMail.mock.calls[0][0].text).toBeTruthy();

            case 10:
            case 'end':
              return _context60.stop();
          }
        }
      }, _callee60, undefined);
    })));
  });

  describe('sendResetPasswordEmail', function () {
    it('throws error if user is not found', _asyncToGenerator(regeneratorRuntime.mark(function _callee61() {
      return regeneratorRuntime.wrap(function _callee61$(_context61) {
        while (1) {
          switch (_context61.prev = _context61.next) {
            case 0:
              Accounts.config({}, {
                findUserByEmail: function findUserByEmail() {
                  return Promise.resolve(null);
                }
              });
              _context61.prev = 1;
              _context61.next = 4;
              return Accounts.sendResetPasswordEmail();

            case 4:
              throw new Error();

            case 7:
              _context61.prev = 7;
              _context61.t0 = _context61['catch'](1);

              expect(_context61.t0.message).toEqual('User not found');

            case 10:
            case 'end':
              return _context61.stop();
          }
        }
      }, _callee61, undefined, [[1, 7]]);
    })));

    it('throws when bad email address passed', _asyncToGenerator(regeneratorRuntime.mark(function _callee62() {
      var user;
      return regeneratorRuntime.wrap(function _callee62$(_context62) {
        while (1) {
          switch (_context62.prev = _context62.next) {
            case 0:
              user = {
                emails: [{ address: 'email' }]
              };

              Accounts.config({}, {
                findUserByEmail: function findUserByEmail() {
                  return Promise.resolve(user);
                }
              });
              _context62.prev = 2;
              _context62.next = 5;
              return Accounts.sendResetPasswordEmail('toto');

            case 5:
              throw new Error();

            case 8:
              _context62.prev = 8;
              _context62.t0 = _context62['catch'](2);

              expect(_context62.t0.message).toEqual('No such email address for user');

            case 11:
            case 'end':
              return _context62.stop();
          }
        }
      }, _callee62, undefined, [[2, 8]]);
    })));

    it('should send to first user email', _asyncToGenerator(regeneratorRuntime.mark(function _callee63() {
      var user;
      return regeneratorRuntime.wrap(function _callee63$(_context63) {
        while (1) {
          switch (_context63.prev = _context63.next) {
            case 0:
              user = {
                emails: [{ address: 'email' }]
              };

              Accounts.config({}, {
                findUserByEmail: function findUserByEmail() {
                  return Promise.resolve(user);
                },
                addResetPasswordToken: function addResetPasswordToken() {
                  return Promise.resolve('token');
                }
              });
              Accounts.email = { sendMail: jest.fn() };
              _context63.next = 5;
              return Accounts.sendResetPasswordEmail('email');

            case 5:
              expect(Accounts.email.sendMail.mock.calls.length).toEqual(1);
              expect(Accounts.email.sendMail.mock.calls[0][0].from).toBeTruthy();
              expect(Accounts.email.sendMail.mock.calls[0][0].to).toEqual('email');
              expect(Accounts.email.sendMail.mock.calls[0][0].subject).toBeTruthy();
              expect(Accounts.email.sendMail.mock.calls[0][0].text).toBeTruthy();

            case 10:
            case 'end':
              return _context63.stop();
          }
        }
      }, _callee63, undefined);
    })));

    it('should send email', _asyncToGenerator(regeneratorRuntime.mark(function _callee64() {
      var user;
      return regeneratorRuntime.wrap(function _callee64$(_context64) {
        while (1) {
          switch (_context64.prev = _context64.next) {
            case 0:
              user = {
                emails: [{ address: 'email' }]
              };

              Accounts.config({}, {
                findUserByEmail: function findUserByEmail() {
                  return Promise.resolve(user);
                },
                addResetPasswordToken: function addResetPasswordToken() {
                  return Promise.resolve('token');
                }
              });
              Accounts.email = { sendMail: jest.fn() };
              _context64.next = 5;
              return Accounts.sendResetPasswordEmail('email');

            case 5:
              expect(Accounts.email.sendMail.mock.calls.length).toEqual(1);
              expect(Accounts.email.sendMail.mock.calls[0][0].from).toBeTruthy();
              expect(Accounts.email.sendMail.mock.calls[0][0].to).toEqual('email');
              expect(Accounts.email.sendMail.mock.calls[0][0].subject).toBeTruthy();
              expect(Accounts.email.sendMail.mock.calls[0][0].text).toBeTruthy();

            case 10:
            case 'end':
              return _context64.stop();
          }
        }
      }, _callee64, undefined);
    })));
  });

  describe('resetPassword', function () {
    it('should reset the password and invalidate all sessions', _asyncToGenerator(regeneratorRuntime.mark(function _callee65() {
      var user, setResetPassswordMock, invalidateAllSessionsMock, hashPass;
      return regeneratorRuntime.wrap(function _callee65$(_context65) {
        while (1) {
          switch (_context65.prev = _context65.next) {
            case 0:
              user = {
                id: 'userId',
                emails: [{ address: 'email' }],
                services: {
                  password: {
                    reset: [{
                      token: 'token',
                      address: 'email',
                      when: Date.now(),
                      reason: 'reset'
                    }]
                  }
                }
              };
              setResetPassswordMock = jest.fn(function () {
                return Promise.resolve();
              });
              invalidateAllSessionsMock = jest.fn();

              Accounts.config({}, {
                findUserByResetPasswordToken: function findUserByResetPasswordToken() {
                  return Promise.resolve(user);
                },
                setResetPasssword: setResetPassswordMock,
                invalidateAllSessions: invalidateAllSessionsMock
              });
              _context65.next = 6;
              return Accounts.resetPassword('token', 'password');

            case 6:
              expect(setResetPassswordMock.mock.calls.length).toEqual(1);
              expect(setResetPassswordMock.mock.calls[0][0]).toEqual('userId');
              expect(setResetPassswordMock.mock.calls[0][1]).toEqual('email');
              hashPass = setResetPassswordMock.mock.calls[0][2];
              _context65.t0 = expect;
              _context65.next = 13;
              return (0, _encryption.verifyPassword)('password', hashPass);

            case 13:
              _context65.t1 = _context65.sent;
              (0, _context65.t0)(_context65.t1).toBeTruthy();

              expect(setResetPassswordMock.mock.calls[0][3]).toEqual('token');
              expect(invalidateAllSessionsMock.mock.calls.length).toEqual(1);
              expect(invalidateAllSessionsMock.mock.calls[0]).toEqual(['userId']);

            case 18:
            case 'end':
              return _context65.stop();
          }
        }
      }, _callee65, undefined);
    })));

    it('throws when token was not found', _asyncToGenerator(regeneratorRuntime.mark(function _callee66() {
      var setResetPassswordMock, invalidateAllSessionsMock;
      return regeneratorRuntime.wrap(function _callee66$(_context66) {
        while (1) {
          switch (_context66.prev = _context66.next) {
            case 0:
              setResetPassswordMock = jest.fn(function () {
                return Promise.resolve();
              });
              invalidateAllSessionsMock = jest.fn();

              Accounts.config({}, {
                findUserByResetPasswordToken: function findUserByResetPasswordToken() {
                  return Promise.resolve(null);
                },
                setResetPasssword: setResetPassswordMock,
                invalidateAllSessions: invalidateAllSessionsMock
              });

              _context66.prev = 3;
              _context66.next = 6;
              return Accounts.resetPassword('token', 'password');

            case 6:
              throw new Error();

            case 9:
              _context66.prev = 9;
              _context66.t0 = _context66['catch'](3);

              expect(_context66.t0.message).toEqual('Reset password link expired');
              expect(setResetPassswordMock.mock.calls.length).toEqual(0);
              expect(invalidateAllSessionsMock.mock.calls.length).toEqual(0);

            case 14:
            case 'end':
              return _context66.stop();
          }
        }
      }, _callee66, undefined, [[3, 9]]);
    })));

    it('throws if token expired', _asyncToGenerator(regeneratorRuntime.mark(function _callee67() {
      var user, setResetPassswordMock, invalidateAllSessionsMock;
      return regeneratorRuntime.wrap(function _callee67$(_context67) {
        while (1) {
          switch (_context67.prev = _context67.next) {
            case 0:
              user = {
                id: 'userId',
                emails: [{ address: 'email' }],
                services: {
                  password: {
                    reset: [{
                      token: 'token',
                      address: 'email',
                      when: 0,
                      reason: 'reset'
                    }]
                  }
                }
              };
              setResetPassswordMock = jest.fn(function () {
                return Promise.resolve();
              });
              invalidateAllSessionsMock = jest.fn();

              Accounts.config({}, {
                findUserByResetPasswordToken: function findUserByResetPasswordToken() {
                  return Promise.resolve(user);
                },
                setResetPasssword: setResetPassswordMock,
                invalidateAllSessions: invalidateAllSessionsMock
              });

              _context67.prev = 4;
              _context67.next = 7;
              return Accounts.resetPassword('token', 'password');

            case 7:
              throw new Error();

            case 10:
              _context67.prev = 10;
              _context67.t0 = _context67['catch'](4);

              expect(_context67.t0.message).toEqual('Reset password link expired');
              expect(setResetPassswordMock.mock.calls.length).toEqual(0);
              expect(invalidateAllSessionsMock.mock.calls.length).toEqual(0);

            case 15:
            case 'end':
              return _context67.stop();
          }
        }
      }, _callee67, undefined, [[4, 10]]);
    })));

    it('throws if emails mismatch for some reason', _asyncToGenerator(regeneratorRuntime.mark(function _callee68() {
      var user, setResetPassswordMock, invalidateAllSessionsMock;
      return regeneratorRuntime.wrap(function _callee68$(_context68) {
        while (1) {
          switch (_context68.prev = _context68.next) {
            case 0:
              user = {
                id: 'userId',
                emails: [{ address: 'email' }],
                services: {
                  password: {
                    reset: [{
                      token: 'token',
                      address: 'email2',
                      when: Date.now(),
                      reason: 'reset'
                    }]
                  }
                }
              };
              setResetPassswordMock = jest.fn(function () {
                return Promise.resolve();
              });
              invalidateAllSessionsMock = jest.fn();

              Accounts.config({}, {
                findUserByResetPasswordToken: function findUserByResetPasswordToken() {
                  return Promise.resolve(user);
                },
                setResetPasssword: setResetPassswordMock,
                invalidateAllSessions: invalidateAllSessionsMock
              });

              _context68.prev = 4;
              _context68.next = 7;
              return Accounts.resetPassword('token', 'password');

            case 7:
              throw new Error();

            case 10:
              _context68.prev = 10;
              _context68.t0 = _context68['catch'](4);

              expect(_context68.t0.message).toEqual('Token has invalid email address');
              expect(setResetPassswordMock.mock.calls.length).toEqual(0);
              expect(invalidateAllSessionsMock.mock.calls.length).toEqual(0);

            case 15:
            case 'end':
              return _context68.stop();
          }
        }
      }, _callee68, undefined, [[4, 10]]);
    })));
  });

  describe('sendEnrollmentEmail', function () {
    it('throws error if user not found', _asyncToGenerator(regeneratorRuntime.mark(function _callee69() {
      return regeneratorRuntime.wrap(function _callee69$(_context69) {
        while (1) {
          switch (_context69.prev = _context69.next) {
            case 0:
              Accounts.config({}, {
                findUserByEmail: function findUserByEmail() {
                  return Promise.resolve(null);
                }
              });
              _context69.prev = 1;
              _context69.next = 4;
              return Accounts.sendEnrollmentEmail('email');

            case 4:
              throw new Error();

            case 7:
              _context69.prev = 7;
              _context69.t0 = _context69['catch'](1);

              expect(_context69.t0.message).toEqual('User not found');

            case 10:
            case 'end':
              return _context69.stop();
          }
        }
      }, _callee69, undefined, [[1, 7]]);
    })));
    it('adds email verification token and sends mail', _asyncToGenerator(regeneratorRuntime.mark(function _callee70() {
      var addResetPasswordToken, _getFirstUserEmail, sendMail;

      return regeneratorRuntime.wrap(function _callee70$(_context70) {
        while (1) {
          switch (_context70.prev = _context70.next) {
            case 0:
              addResetPasswordToken = jest.fn();
              _getFirstUserEmail = jest.fn(function () {
                return 'user@user.com';
              });
              sendMail = jest.fn();

              Accounts.config({
                siteUrl: 'siteUrl'
              }, {
                findUserByEmail: function findUserByEmail() {
                  return Promise.resolve({
                    id: 'userId',
                    emails: [{
                      address: 'user@user.com',
                      verified: false
                    }]
                  });
                },
                addResetPasswordToken: addResetPasswordToken
              });
              Accounts._getFirstUserEmail = _getFirstUserEmail;
              Accounts.email.sendMail = sendMail;
              _context70.next = 8;
              return Accounts.sendEnrollmentEmail('user@user.com');

            case 8:
              expect(addResetPasswordToken.mock.calls[0][0]).toEqual('userId');
              expect(addResetPasswordToken.mock.calls[0][1]).toEqual('user@user.com');
              expect(addResetPasswordToken.mock.calls[0][3]).toEqual('enroll');
              expect(sendMail.mock.calls.length).toEqual(1);

            case 12:
            case 'end':
              return _context70.stop();
          }
        }
      }, _callee70, undefined);
    })));
  });

  describe('_getFirstUserEmail', function () {
    it('throws error if email does not exist', function () {
      try {
        Accounts._getFirstUserEmail({
          emails: [{
            address: '',
            verified: false
          }]
        });
        throw new Error();
      } catch (err) {
        expect(err.message).toEqual('No such email address for user');
      }
      try {
        Accounts._getFirstUserEmail({
          emails: [{
            address: 'wrongemail@email.com',
            verified: false
          }]
        }, 'email');
        throw new Error();
      } catch (err) {
        expect(err.message).toEqual('No such email address for user');
      }
    });
    it('returns first email', function () {
      var email = Accounts._getFirstUserEmail({
        emails: [{
          address: 'email@email.com',
          verified: false
        }, {
          address: 'another@email.com',
          verified: false
        }]
      });
      expect(email).toEqual('email@email.com');
    });
  });

  describe('impersonate', function () {
    var user = { username: 'myUser', id: 123 };
    var impersonatedUser = { username: 'impUser', id: 456 };
    var someUser = { username: 'someUser', id: 789 };

    it('throws error if no access token is provided', _asyncToGenerator(regeneratorRuntime.mark(function _callee71() {
      return regeneratorRuntime.wrap(function _callee71$(_context71) {
        while (1) {
          switch (_context71.prev = _context71.next) {
            case 0:
              Accounts.config({}, db);
              _context71.prev = 1;
              _context71.next = 4;
              return Accounts.impersonate();

            case 4:
              throw new Error();

            case 7:
              _context71.prev = 7;
              _context71.t0 = _context71['catch'](1);

              expect(_context71.t0.message).toEqual('An access token is required');

            case 10:
            case 'end':
              return _context71.stop();
          }
        }
      }, _callee71, undefined, [[1, 7]]);
    })));

    it('returns not authorized if impersonationAuthorize function is not passed in config', _asyncToGenerator(regeneratorRuntime.mark(function _callee73() {
      var _Accounts$createToken21, accessToken, impersonationAuthorize, res;

      return regeneratorRuntime.wrap(function _callee73$(_context73) {
        while (1) {
          switch (_context73.prev = _context73.next) {
            case 0:
              _Accounts$createToken21 = Accounts.createTokens('555'), accessToken = _Accounts$createToken21.accessToken;

              Accounts.config({
                //eslint-disable-next-line
                impersonationAuthorize: function () {
                  var _ref73 = _asyncToGenerator(regeneratorRuntime.mark(function _callee72(userObject, impersonateToUser) {
                    return regeneratorRuntime.wrap(function _callee72$(_context72) {
                      while (1) {
                        switch (_context72.prev = _context72.next) {
                          case 0:
                            return _context72.abrupt('return', userObject.id === user.id && impersonateToUser === impersonatedUser);

                          case 1:
                          case 'end':
                            return _context72.stop();
                        }
                      }
                    }, _callee72, undefined);
                  }));

                  return function impersonationAuthorize(_x3, _x4) {
                    return _ref73.apply(this, arguments);
                  };
                }()
              }, {
                findUserById: function findUserById() {
                  return Promise.resolve(user);
                },
                findUserByUsername: function findUserByUsername() {
                  return Promise.resolve(someUser);
                }
              });

              Accounts.findSessionByAccessToken = function () {
                return Promise.resolve({
                  valid: true,
                  userId: '123'
                });
              };

              impersonationAuthorize = Accounts.options().impersonationAuthorize;

              expect(impersonationAuthorize).toBeDefined();

              _context73.next = 7;
              return Accounts.impersonate(accessToken, 'someUser');

            case 7:
              res = _context73.sent;

              expect(res.authorized).toEqual(false);

            case 9:
            case 'end':
              return _context73.stop();
          }
        }
      }, _callee73, undefined);
    })));

    it('returns correct response if authorized', _asyncToGenerator(regeneratorRuntime.mark(function _callee75() {
      var _Accounts$createToken22, accessToken, createSession, res;

      return regeneratorRuntime.wrap(function _callee75$(_context75) {
        while (1) {
          switch (_context75.prev = _context75.next) {
            case 0:
              _Accounts$createToken22 = Accounts.createTokens('555'), accessToken = _Accounts$createToken22.accessToken;
              createSession = jest.fn(function () {
                return Promise.resolve('001');
              });

              Accounts.config({
                //eslint-disable-next-line
                impersonationAuthorize: function () {
                  var _ref75 = _asyncToGenerator(regeneratorRuntime.mark(function _callee74(userObject, impersonateToUser) {
                    return regeneratorRuntime.wrap(function _callee74$(_context74) {
                      while (1) {
                        switch (_context74.prev = _context74.next) {
                          case 0:
                            return _context74.abrupt('return', userObject.id === user.id && impersonateToUser === impersonatedUser);

                          case 1:
                          case 'end':
                            return _context74.stop();
                        }
                      }
                    }, _callee74, undefined);
                  }));

                  return function impersonationAuthorize(_x5, _x6) {
                    return _ref75.apply(this, arguments);
                  };
                }()
              }, {
                findUserById: function findUserById() {
                  return Promise.resolve(user);
                },
                findUserByUsername: function findUserByUsername() {
                  return Promise.resolve(impersonatedUser);
                },
                createSession: createSession
              });

              Accounts.findSessionByAccessToken = function () {
                return Promise.resolve({
                  valid: true,
                  userId: '123'
                });
              };
              Accounts.createTokens = function (sessionId, isImpersonated) {
                return { sessionId: sessionId, isImpersonated: isImpersonated };
              };

              _context75.next = 7;
              return Accounts.impersonate(accessToken, 'impUser');

            case 7:
              res = _context75.sent;

              expect(res).toEqual({
                authorized: true,
                tokens: { sessionId: '001', isImpersonated: true },
                user: impersonatedUser
              });
              expect(createSession).toHaveBeenCalledWith(impersonatedUser.id, undefined, undefined, { impersonatorUserId: user.id });

            case 10:
            case 'end':
              return _context75.stop();
          }
        }
      }, _callee75, undefined);
    })));
  });

  describe('user sanitizer', function () {
    var userObject = { username: 'test', services: [], id: '123' };

    it('internal sanitizer should clean services field from the user object', function () {
      Accounts.config({}, db);
      var modifiedUser = Accounts._sanitizeUser(userObject);
      expect(modifiedUser.services).toBeUndefined();
    });

    it('should run external sanitizier when provided one', function () {
      Accounts.config({
        userObjectSanitizer: function userObjectSanitizer(user, omit) {
          return omit(user, ['username']);
        }
      }, db);
      var modifiedUser = Accounts._sanitizeUser(userObject);
      expect(modifiedUser.username).toBeUndefined();
    });
  });
});