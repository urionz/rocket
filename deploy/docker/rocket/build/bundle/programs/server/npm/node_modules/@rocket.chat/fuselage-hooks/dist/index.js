'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var react = require('react');
var invariant = _interopDefault(require('invariant'));

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

var fromCamelToKebabCase = function fromCamelToKebabCase(camelCaseString) {
  return camelCaseString.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2').toLowerCase();
};
var debounce = function debounce(fn, delay) {
  var timer;
  var callback;

  function f() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var context = this;
    clearTimeout(timer);

    callback = function callback() {
      return fn.apply(context, args);
    };

    timer = setTimeout(callback, delay);
    return context;
  }

  f.flush = function () {
    clearTimeout(timer);
    callback();
  };

  f.cancel = function () {
    return clearTimeout(timer);
  };

  return f;
};

/**
 * Hook to generate a BEM-compatible `className` value for a component.
 *
 * @param componentClassName - the style class which identifies the component
 * @param modifiers - the modifiers applied to the style class
 * @param classNames - the additional style classes appended to the `className`
 * @return a BEM-compatible `className` in the format
 *  `(<block>|<block>__<element>) [...(<block>--<modifier>|<block>__<element>--<modifier>)] [...classNames]`
 */

var useClassName = function useClassName(componentClassName) {
  var modifiers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  for (var _len = arguments.length, classNames = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    classNames[_key - 2] = arguments[_key];
  }

  return react.useMemo(function () {
    return [componentClassName].concat(_toConsumableArray(Object.entries(modifiers).filter(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          value = _ref2[1];

      return !!value;
    }).map(function (_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2),
          key = _ref4[0],
          value = _ref4[1];

      return typeof value === 'boolean' ? "".concat(componentClassName, "--").concat(fromCamelToKebabCase(key)) : "".concat(componentClassName, "--").concat(fromCamelToKebabCase(key), "-").concat(fromCamelToKebabCase(String(value)));
    })), classNames).filter(Boolean).join(' ');
  }, [componentClassName, Object.entries(modifiers).reduce(function (deps, _ref5) {
    var _ref6 = _slicedToArray(_ref5, 2),
        name = _ref6[0],
        value = _ref6[1];

    return [].concat(_toConsumableArray(deps), [name, value]);
  }, []), JSON.stringify(classNames)]);
};

/**
 * Hook to memoize a debounced version of a callback.
 *
 * @param callback the callback to debounce
 * @param delay the number of milliseconds to delay
 * @param deps the hook dependencies
 * @return a memoized and debounced callback
 */

var useDebouncedCallback = function useDebouncedCallback(callback, delay, deps) {
  return react.useMemo(function () {
    return debounce(callback, delay);
  }, Array.isArray(deps) ? [delay].concat(_toConsumableArray(deps)) : undefined);
};

/**
 * Hook to debounce the state updater function returned by hooks like `useState()` and `useReducer()`.
 *
 * @param pair - the state and updater pair which will be debounced
 * @param pair.0 - the state value
 * @param pair.1 - the state updater function
 * @param delay - the number of milliseconds to delay the updater
 * @return a state value and debounced updater pair
 */

var useDebouncedUpdates = function useDebouncedUpdates(_ref, delay) {
  var _ref2 = _slicedToArray(_ref, 2),
      value = _ref2[0],
      update = _ref2[1];

  return [value, useDebouncedCallback(update, delay, [])];
};
/**
 * Hook to create a reduced state with a debounced `dispatch()` function.
 *
 * @param reducer - the reducer function
 * @param initializerArg - the initial state value or the argument passed to the initial state generator function
 * @param initializer - the initial state generator function
 * @param delay - the number of milliseconds to delay the updater
 * @return a state and debounced `dispatch()` function
 */

var useDebouncedReducer = function useDebouncedReducer(reducer, initializerArg, initializer, delay) {
  return useDebouncedUpdates(react.useReducer(reducer, initializerArg, initializer), delay);
};
/**
 * Hook to create a state with a debounced setter function.
 *
 * @param initialValue - the initial state value or the initial state generator function
 * @param delay - the number of milliseconds to delay the updater
 * @return a state and debounced setter function
 */

var useDebouncedState = function useDebouncedState(initialValue, delay) {
  return useDebouncedUpdates(react.useState(initialValue), delay);
};

/**
 * Hook for asserting mutually exclusive boolean props. Useful for components that use boolean props
 * to choose styling variants.
 *
 * @param props - the mutually exclusive boolean props
 * @throws if two or more booleans props are set as true
 */

var useExclusiveBooleanProps = function useExclusiveBooleanProps(props) {
  return invariant(Object.values(props).filter(Boolean).length <= 1, "Only one property of [".concat(Object.keys(props).join(', '), "] should be true"));
};

/**
 * Hook to listen to a media query.
 *
 * @param [query] - the CSS3 media query expression
 * @return `true` if the media query matches; `false` is it does not match or the query is not defined
 */

var useMediaQuery = function useMediaQuery(query) {
  var _useState = react.useState(function () {
    if (!query) {
      return false;
    }

    var _window$matchMedia = window.matchMedia(query),
        matches = _window$matchMedia.matches;

    return !!matches;
  }),
      _useState2 = _slicedToArray(_useState, 2),
      matches = _useState2[0],
      setMatches = _useState2[1];

  react.useLayoutEffect(function () {
    if (!query) {
      return;
    }

    var mounted = true;
    var mql = window.matchMedia(query);

    var handleChange = function handleChange() {
      if (!mounted) {
        return;
      }

      setMatches(!!mql.matches);
    };

    mql.addListener(handleChange);
    setMatches(mql.matches);
    return function () {
      mounted = false;
      mql.removeListener(handleChange);
    };
  }, [query]);
  return matches;
};

/**
 * Hook to merge refs and callbacks refs into a single callback ref. Useful when your component need a internal ref
 * while receiving a forwared ref.
 *
 * @param refs - the refs and callback refs that should be merged
 * @return a merged callback ref
 */
var useMergedRefs = function useMergedRefs() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
    refs[_key] = arguments[_key];
  }

  return react.useCallback(function (refValue) {
    refs.filter(Boolean).forEach(function (ref) {
      if (typeof ref === 'function') {
        ref(refValue);
        return;
      }

      if (_typeof(ref) === 'object') {
        ref.current = refValue;
      }
    });
  }, refs);
};

/**
 * Hook to create a toggleable boolean state.
 *
 * @param initialValue - the initial value or the initial state generator function
 * @return a state boolean value and a state toggler function
 */

var useToggle = function useToggle(initialValue) {
  var _useState = react.useState(function () {
    return typeof initialValue === 'function' ? !!initialValue() : !!initialValue;
  }),
      _useState2 = _slicedToArray(_useState, 2),
      value = _useState2[0],
      setValue = _useState2[1];

  return [value, function (forcedValue) {
    return setValue(typeof forcedValue !== 'undefined' ? forcedValue : !value);
  }];
};

var useUniqueId = function useUniqueId() {
  return react.useMemo(function () {
    return Math.random().toString(36).slice(2);
  }, []);
};

exports.useClassName = useClassName;
exports.useDebouncedCallback = useDebouncedCallback;
exports.useDebouncedReducer = useDebouncedReducer;
exports.useDebouncedState = useDebouncedState;
exports.useDebouncedUpdates = useDebouncedUpdates;
exports.useExclusiveBooleanProps = useExclusiveBooleanProps;
exports.useMediaQuery = useMediaQuery;
exports.useMergedRefs = useMergedRefs;
exports.useToggle = useToggle;
exports.useUniqueId = useUniqueId;
//# sourceMappingURL=index.js.map
